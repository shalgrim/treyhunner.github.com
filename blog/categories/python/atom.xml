<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: python | Trey Hunner]]></title>
  <link href="http://treyhunner.com/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://treyhunner.com/"/>
  <updated>2019-03-31T13:25:33-07:00</updated>
  <id>http://treyhunner.com/</id>
  <author>
    <name><![CDATA[Trey Hunner]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Overusing list comprehensions and generator expressions in Python]]></title>
    <link href="http://treyhunner.com/2019/03/abusing-and-overusing-list-comprehensions-in-python/"/>
    <updated>2019-03-26T13:30:00-07:00</updated>
    <id>http://treyhunner.com/2019/03/abusing-and-overusing-list-comprehensions-in-python</id>
    <content type="html"><![CDATA[<p>List comprehensions are one of my favorite features in Python.
I love list comprehensions so much that I&rsquo;ve written an <a href="https://treyhunner.com/2015/12/python-list-comprehensions-now-in-color/" title="List Comprehensions: Explain Visually">article</a> about them, done <a href="https://youtu.be/5_cJIcgM7rw" title="Comprehensible Comprehensions">a talk</a> about them, and held a <a href="https://youtu.be/_6U1XoxyyBY" title="Using List Comprehensions and Generator Expressions For Data Processing">3 hour comprehensions tutorial</a> at PyCon 2018.</p>

<p>While I love list comprehensions, I&rsquo;ve found that once new Pythonistas start to really appreciate comprehensions they tend to use them everywhere.
<strong>Comprehensions are lovely, but they can easily be overused</strong>!</p>

<p>This article is all about cases when comprehensions aren&rsquo;t the best tool for the job, at least in terms of readability.
We&rsquo;re going to walk through a number of cases where there&rsquo;s a more readable alternative to comprehensions and we&rsquo;ll also see some not-so-obvious cases where comprehensions aren&rsquo;t needed at all.</p>

<p>This article isn&rsquo;t meant to scare you off from comprehensions if you&rsquo;re not already a fan; it&rsquo;s meant to encourage moderation for those of us (myself included) who need it.</p>

<p><strong>Note</strong>: In this article, I&rsquo;ll be using the term &ldquo;comprehension&rdquo; to refer to all forms of comprehensions (list, set, dict) as well as generator expressions.
If you&rsquo;re unfamiliar with comprehensions, I recommend reading <a href="https://treyhunner.com/2015/12/python-list-comprehensions-now-in-color/" title="List Comprehensions: Explain Visually">this article</a> or watching <a href="https://youtu.be/5_cJIcgM7rw" title="Comprehensible Comprehensions">this talk</a> (the talk dives into generator expressions a bit more deeply).</p>

<h2>Writing comprehensions with poor spacing</h2>

<p>Critics of list comprehensions often say they&rsquo;re hard to read.
And they&rsquo;re right, many comprehensions <em>are</em> hard to read.
<strong>Sometimes all a comprehension needs to be more readable is better spacing</strong>.</p>

<p>Take the comprehension in this function:</p>

<pre><code class="python">def get_factors(dividend):
    """Return a list of all factors of the given number."""
    return [n for n in range(1, dividend+1) if dividend % n == 0]
</code></pre>

<p>We could make that comprehension more readable by adding some well-placed line breaks:</p>

<pre><code class="python">def get_factors(dividend):
    """Return a list of all factors of the given number."""
    return [
        n
        for n in range(1, dividend+1)
        if dividend % n == 0
    ]
</code></pre>

<p>Less code can mean more readable code, but not always.
<strong>Whitespace is your friend, especially when you&rsquo;re writing comprehensions</strong>.</p>

<p>In general, I prefer to write most of my comprehensions <strong>spaced out over multiple lines of code</strong> using the indentation style above.
I do write one-line comprehensions sometimes, but I don&rsquo;t default to them.</p>

<h2>Writing ugly comprehensions</h2>

<p>Some loops technically <em>can</em> be written as comprehensions but they have so much logic in them they probably <em>shouldn&rsquo;t</em> be.</p>

<p>Take this comprehension:</p>

<pre><code class="python">fizzbuzz = [
    f'fizzbuzz {n}' if n % 3 == 0 and n % 5 == 0
    else f'fizz {n}' if n % 3 == 0
    else f'buzz {n}' if n % 5 == 0
    else n
    for n in range(100)
]
</code></pre>

<p>This comprehension is equivalent to this <code>for</code> loop:</p>

<pre><code class="python">fizzbuzz = []
for n in range(100):
    fizzbuzz.append(
        f'fizzbuzz {n}' if n % 3 == 0 and n % 5 == 0
        else f'fizz {n}' if n % 3 == 0
        else f'buzz {n}' if n % 5 == 0
        else n
    )
</code></pre>

<p>Both the comprehension and the <code>for</code> loop use three nested <a href="https://docs.python.org/3/faq/programming.html#is-there-an-equivalent-of-c-s-ternary-operator">inline if statements</a> (Python&rsquo;s <a href="https://en.wikipedia.org/wiki/%3F:">ternary operator</a>).</p>

<p>Here&rsquo;s a more readable way to write this code, using an <code>if-elif-else</code> construct:</p>

<pre><code class="python">fizzbuzz = []
for n in range(100):
    if n % 3 == 0 and n % 5 == 0:
        fizzbuzz.append(f'fizzbuzz {n}')
    elif n % 3 == 0:
        fizzbuzz.append(f'fizz {n}')
    elif n % 5 == 0:
        fizzbuzz.append(f'buzz {n}')
    else:
        fizzbuzz.append(n)
</code></pre>

<p>Just because there <em>is</em> a way to write your code as a comprehension, <strong>that doesn&rsquo;t mean that you <em>should</em> write your code as a comprehension</strong>.</p>

<p>Be careful using any amount of complex logic in comprehensions, even a single <a href="https://docs.python.org/3/faq/programming.html#is-there-an-equivalent-of-c-s-ternary-operator">inline if</a>:</p>

<pre><code class="python">number_things = [
    n // 2 if n % 2 == 0 else n * 3
    for n in numbers
]
</code></pre>

<p>If you really prefer to use a comprehension in cases like this, at least give some thought to <strong>whether whitespace or parenthesis could make things more readable</strong>:</p>

<pre><code class="python">number_things = [
    (n // 2 if n % 2 == 0 else n * 3)
    for n in numbers
]
</code></pre>

<p>And consider whether breaking some of your logic out into a separate function might improve readability as well (it may not in this somewhat silly example).</p>

<pre><code class="python">number_things = [
    even_odd_number_switch(n)
    for n in numbers
]
</code></pre>

<p>Whether a separate function makes things more readable will depend on how important that operation is, how large it is, and how well the function name conveys the operation.</p>

<h2>Loops disguised as comprehensions</h2>

<p>Sometimes you&rsquo;ll encounter code that uses a comprehension syntax but breaks the spirit of what comprehensions are used for.</p>

<p>For example, this code looks like a comprehension:</p>

<pre><code class="python">[print(n) for n in range(1, 11)]
</code></pre>

<p>But it doesn&rsquo;t <em>act</em> like a comprehension.
We&rsquo;re using a comprehension for a purpose it wasn&rsquo;t intended for.</p>

<p>If we execute this comprehension in the Python shell you&rsquo;ll see what I mean:</p>

<pre><code class="python">&gt;&gt;&gt; [print(n) for n in range(1, 11)]
1
2
3
4
5
6
7
8
9
10
[None, None, None, None, None, None, None, None, None, None]
</code></pre>

<p>We wanted to print out all the numbers from 1 to 10 and that&rsquo;s what we did.
But this comprehension statement also returned a list of <code>None</code> values to us, which we promptly discarded.</p>

<p><strong>Comprehensions build up lists: that&rsquo;s what they&rsquo;re for</strong>.
We built up a list of the return values from the <code>print</code> function and the <code>print</code> function returns <code>None</code>.</p>

<p>But we didn&rsquo;t care about the list our comprehension built up: we only cared about its side effect.</p>

<p>We could have instead written that code like this:</p>

<pre><code class="python">for n in range(1, 11):
    print(n)
</code></pre>

<p>List comprehensions are for <strong>looping over an iterable and building up new lists</strong>, while <code>for</code> loops are for <strong>looping over an iterable to do pretty much any operation you&rsquo;d like</strong>.</p>

<p>When I see a list comprehension in code <strong>I immediately assume that we&rsquo;re building up a new list</strong> (because that&rsquo;s what they&rsquo;re for).
If you use a comprehension for <strong>a purpose outside of building up a new list</strong>, it&rsquo;ll confuse others who read your code.</p>

<p>If you don&rsquo;t care about building up a new list, don&rsquo;t use a comprehension.</p>

<h2>Using comprehensions when a more specific tool exists</h2>

<p>For many problems, a more specific tool makes more sense than a general purpose <code>for</code> loop.
<strong>But comprehensions aren&rsquo;t always the best special-purpose tool for the job at hand.</strong></p>

<p>I have both seen and written quite a bit of code that looks like this:</p>

<pre><code class="python">import csv

with open('populations.csv') as csv_file:
    lines = [
        row
        for row in csv.reader(csv_file)
    ]
</code></pre>

<p>That comprehension is sort of an <em>identity</em> comprehension.
Its only purpose is to loop over the given iterable (<code>csv.reader(csv_file)</code>) and create a list out of it.</p>

<p>But in Python, we have a more specialized tool for this task: the <code>list</code> constructor.
Python&rsquo;s <code>list</code> constructor can do all the looping and list creation work for us:</p>

<pre><code class="python">import csv

with open('populations.csv') as csv_file:
    lines = list(csv.reader(csv_file))
</code></pre>

<p>Comprehensions are a special-purpose tool for looping over an iterable to build up a new list while modifying each element along the way and/or filtering elements down.
The <code>list</code> constructor is a special-purpose tool for looping over an iterable to build up a new list, without changing anything at all.</p>

<p>If you don&rsquo;t need to filter your elements down or map them into new elements while building up your new list, <strong>you don&rsquo;t need a comprehension: you need the <code>list</code> constructor</strong>.</p>

<p>This comprehension converts each of the <code>row</code> tuples we get from looping over <code>zip</code> into lists:</p>

<pre><code class="python">def transpose(matrix):
    """Return a transposed version of given list of lists."""
    return [
        [n for n in row]
        for row in zip(*matrix)
    ]
</code></pre>

<p>We could use the <code>list</code> constructor for that too:</p>

<pre><code class="python">def transpose(matrix):
    """Return a transposed version of given list of lists."""
    return [
        list(row)
        for row in zip(*matrix)
    ]
</code></pre>

<p>Whenever you see a comprehension like this:</p>

<pre><code class="python">my_list = [x for x in some_iterable]
</code></pre>

<p>You could write this instead:</p>

<pre><code class="python">my_list = list(some_iterable)
</code></pre>

<p>The same applies for <code>dict</code> and <code>set</code> comprehensions.</p>

<p>This is also something I&rsquo;ve written quite a bit in the past:</p>

<pre><code class="python">states = [
    ('AL', 'Alabama'),
    ('AK', 'Alaska'),
    ('AZ', 'Arizona'),
    ('AR', 'Arkansas'),
    ('CA', 'California'),
    # ...
]

abbreviations_to_names = {
    abbreviation: name
    for abbreviation, name in states
}
</code></pre>

<p>Here we&rsquo;re looping over a list of two-item tuples and making a dictionary out of them.</p>

<p>This task is exactly what the <code>dict</code> constructor was made for:</p>

<pre><code class="python">abbreviations_to_names = dict(states)
</code></pre>

<p>The built-in <code>list</code> and <code>dict</code> constructors aren&rsquo;t the only comprehension-replacing tools.
The standard library and third-party libraries also include tools that are sometimes better suited for your looping needs than a comprehension.</p>

<p>Here&rsquo;s a generator expression that sums up an iterable-of-iterables-of-numbers:</p>

<pre><code class="python">def sum_all(number_lists):
    """Return the sum of all numbers in the given list-of-lists."""
    return sum(
        n
        for numbers in number_lists
        for n in numbers
    )
</code></pre>

<p>And here&rsquo;s the same thing using <code>itertools.chain</code>:</p>

<pre><code class="python">from itertools import chain

def sum_all(number_lists):
    """Return the sum of all numbers in the given list-of-lists."""
    return sum(chain.from_iterable(number_lists))
</code></pre>

<p>When you should use a comprehension and when you should use the alternative isn&rsquo;t always straightforward.</p>

<p>I&rsquo;m often torn on whether to use <code>itertools.chain</code> or a comprehension.
I usually write my code both ways and then go with the one that seems clearer.</p>

<p>Readability is fairly problem-specific with many programming constructs, comprehensions included.</p>

<h2>Needless work</h2>

<p>Sometimes you&rsquo;ll see comprehensions that shouldn&rsquo;t be replaced by another construct but should instead be <strong>removed entirely</strong>, leaving only the iterable they loop over.</p>

<p>Here we&rsquo;re opening up a file of words (with one word per line), storing file in memory, and counting the number of times each occurs:</p>

<pre><code class="python">from collections import Counter

word_counts = Counter(
    word
    for word in open('word_list.txt').read().splitlines()
)
</code></pre>

<p>We&rsquo;re using a generator expression here, but we don&rsquo;t need to be.
This works just as well:</p>

<pre><code class="python">from collections import Counter

word_counts = Counter(open('word_list.txt').read().splitlines())
</code></pre>

<p>We were looping over a list to convert it to a generator before passing it to the <code>Counter</code> class.
That was needless work!
The <code>Counter</code> class accepts <strong>any iterable: it doesn&rsquo;t care whether they&rsquo;re lists, generators, tuples, or something else</strong>.</p>

<p>Here&rsquo;s another needless comprehension:</p>

<pre><code class="python">with open('word_list.txt') as words_file:
    lines = [line for line in words_file]
    for line in lines:
        if 'z' in line:
            print('z word', line, end='')
</code></pre>

<p>We&rsquo;re looping over <code>words_file</code>, converting it to a list of <code>lines</code>, and then looping over <code>lines</code> just once.
That conversion to a list was unnecessary.</p>

<p>We could just loop over <code>words_file</code> directly instead:</p>

<pre><code class="python">with open('word_list.txt') as words_file:
    for line in words_file:
        if 'z' in line:
            print('z word', line, end='')
</code></pre>

<p>There&rsquo;s no reason to convert an iterable to a list if all we&rsquo;re going to do is loop over it once.</p>

<p>In Python, we often care less about <strong>whether something is a list</strong> and more about <strong>whether it&rsquo;s an iterable</strong>.</p>

<p>Be careful not to create new iterables when you don&rsquo;t need to: <strong>if you&rsquo;re only going to loop over an iterable once, just use the iterable you already have</strong>.</p>

<h2>When would I use a comprehension?</h2>

<p>So when would you actually use a comprehension?</p>

<p>The simple but imprecise answer is whenever you can write your code in the below <a href="https://treyhunner.com/2015/12/python-list-comprehensions-now-in-color/" title="List Comprehensions: Explain Visually">comprehension copy-pasteable format</a> and there isn&rsquo;t another tool you&rsquo;d rather use for shortening your code, you should consider using a list comprehension.</p>

<pre><code class="python">new_things = []
for ITEM in old_things:
    if condition_based_on(ITEM):
        new_things.append(some_operation_on(ITEM))
</code></pre>

<p>That loop can be rewritten as this comprehension:</p>

<pre><code class="python">new_things = [
    some_operation_on(ITEM)
    for ITEM in old_things
    if condition_based_on(ITEM)
]
</code></pre>

<p>The complex answer is whenever comprehensions make sense, you should consider them.
That&rsquo;s not really an answer, but there is no one answer to the question &ldquo;when should I use a comprehension&rdquo;?</p>

<p>For example here&rsquo;s a <code>for</code> loop which doesn&rsquo;t really look like it could be rewritten using a comprehension:</p>

<pre><code class="python">def is_prime(candidate):
    for n in range(2, candidate):
        if candidate % n == 0:
            return False
    return True
</code></pre>

<p>But there is in fact another way to write this loop using a generator expression, if we know how to use the built-in <code>all</code> function:</p>

<pre><code class="python">def is_prime(candidate):
    return all(
        candidate % n != 0
        for n in range(2, candidate)
    )
</code></pre>

<p>I wrote <a href="https://treyhunner.com/2016/11/check-whether-all-items-match-a-condition-in-python/">a whole article on the <code>any</code> and <code>all</code> functions</a> and how they pair so nicely with generator expressions.
But <code>any</code> and <code>all</code> aren&rsquo;t alone in their affinity for generator expressions.</p>

<p>We have a similar situation with this code:</p>

<pre><code class="python">def sum_of_squares(numbers):
    total = 0
    for n in numbers:
        total += n**2
    return total
</code></pre>

<p>There&rsquo;s no <code>append</code> there and no new iterable being built up.
But if we create a generator of squares, we could pass them to the built-in <code>sum</code> function to get the same result:</p>

<pre><code class="python">def sum_of_squares(numbers):
    return sum(n**2 for n in numbers)
</code></pre>

<p>So in addition to the &ldquo;can I copy-paste my way from a loop to a comprehension&rdquo; check, there&rsquo;s another, fuzzier, check to consider: could your code be enhanced by a generator expression combined with an iterable-accepting function or class?</p>

<p>Any function or class that <strong>accepts an iterable as an argument</strong> <em>might</em> be a good candidate for <strong>combining with a generator expression</strong>.</p>

<h2>Use list comprehensions thoughtfully</h2>

<p>List comprehensions can make your code more readable (if you don&rsquo;t believe me, see the examples in my <a href="https://youtu.be/5_cJIcgM7rw" title="Comprehensible Comprehensions">Comprehensible Comprehensions</a> talk), but they can definitely be abused.</p>

<p>List comprehensions are a special-purpose tool for solving a specific problem.
The <code>list</code> and <code>dict</code> constructors are <strong>even more special-purpose tools</strong> for solving even more specific problems.</p>

<p>Loops are <strong>a more general purpose tool</strong> for times when you have a problem that doesn&rsquo;t fit within the realm of comprehensions or another special-purpose looping tool.</p>

<p>Functions like <code>any</code>, <code>all</code>, and <code>sum</code>, and classes like <code>Counter</code> and <code>chain</code> are iterable-accepting tools that <strong>pair very nicely with comprehensions</strong> and sometimes <strong>replace the need for comprehensions entirely</strong>.</p>

<p>Remember that comprehensions are for a single purpose: <strong>creating a new iterable from an old iterable</strong>, while tweaking values slightly along the way and/or for filtering out values that don&rsquo;t match a certain condition.
Comprehensions are a lovely tool, but <strong>they&rsquo;re not your only tool</strong>.
Don&rsquo;t forget the <code>list</code> and <code>dict</code> constructors and always consider <code>for</code> loops when your comprehensions get out of hand.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unique sentinel values, identity checks, and when to use object() instead of None]]></title>
    <link href="http://treyhunner.com/2019/03/unique-and-sentinel-values-in-python/"/>
    <updated>2019-03-20T07:30:00-07:00</updated>
    <id>http://treyhunner.com/2019/03/unique-and-sentinel-values-in-python</id>
    <content type="html"><![CDATA[<p>Occasionally in Python (and in programming in general), you&rsquo;ll need an object which can be uniquely identified.
Sometimes this unique object represents a <strong>stop value</strong> or a <strong>skip value</strong> and sometimes it&rsquo;s an <strong>initial value</strong>.
But in each of these cases you want your object to stand out from the other objects you&rsquo;re working with.</p>

<p>When you need a unique value (a <strong>sentinel value</strong> maybe) <code>None</code> is often the value to reach for.
But sometimes <code>None</code> isn&rsquo;t enough: sometimes <code>None</code> is ambiguous.</p>

<p>In this article we&rsquo;ll talk about when <code>None</code> isn&rsquo;t enough, I&rsquo;ll show you how I create unique values when <code>None</code> doesn&rsquo;t cut it, and we&rsquo;ll see a few different uses for this technique.</p>

<h2>Initial values and default values</h2>

<p>Let&rsquo;s re-implement a version of Python&rsquo;s built-in <code>min</code> function.</p>

<pre><code class="python">def min(iterable, default=None):
    """Imperfect re-implementation of Python's built-in min function."""
    minimum = None
    for item in iterable:
        if minimum is None or item &lt; minimum:
            minimum = item
    if minimum is not None:
        return minimum
    elif default is not None:
        return default
    else:
        raise ValueError("Empty iterable")
</code></pre>

<p>This <code>min</code> function, like the built-in one, returns the minimum value in the given iterable or raises an exception when an empty iterable is given unless a default value is specified (in which case the default is returned).</p>

<pre><code class="python">&gt;&gt;&gt; min([4, 3, 8, 7])
3
&gt;&gt;&gt; min([9])
9
&gt;&gt;&gt; min([])
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 12, in min
ValueError: Empty iterable
&gt;&gt;&gt; min([], default=9)
9
&gt;&gt;&gt; min([4, 3, 8, 7], default=9)
3
</code></pre>

<p>This behavior is somewhat similar to the built-in <code>min</code> function, except <strong>our code is buggy</strong>!</p>

<p>There are two bugs here.</p>

<p>First, an iterable containing a single <code>None</code> value will be treated as if it was an empty iterable:</p>

<pre><code class="python">&gt;&gt;&gt; min([None], default=0)
0
&gt;&gt;&gt; min([None])
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 8, in min
ValueError: Empty iterable
</code></pre>

<p>Second, if we specify our <code>default</code> value as <code>None</code> this <code>min</code> function won&rsquo;t accept it:</p>

<pre><code class="python">&gt;&gt;&gt; min([], default='')
''
&gt;&gt;&gt; min([], default=None)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 12, in min
ValueError: Empty iterable
</code></pre>

<p>Why is this happening?</p>

<p>It&rsquo;s all about <code>None</code>.</p>

<h2>Why is <code>None</code> a problem?</h2>

<p>The first bug in our code is related to the initial value for <code>minimum</code> and the second is related to the default value for our <code>default</code> argument.
In both cases, <strong>we&rsquo;re using <code>None</code> to represent an <em>unspecified</em> or <em>un-initialized</em> value</strong>.</p>

<pre><code class="python">def min(iterable, default=None):
    """Imperfect re-implementation of Python's built-in min function."""
    minimum = None
    for item in iterable:
        if minimum is None or item &lt; minimum:
            minimum = item
    if minimum is not None:
        return minimum
    elif default is not None:
        return default
    else:
        raise ValueError("Empty iterable")
</code></pre>

<p>Using <code>None</code> is a problem in both cases because <code>None</code> is both a valid value for <code>default</code> and a valid value in our iterable.</p>

<p>Python&rsquo;s <code>None</code> value is useful for representing emptiness, but it isn&rsquo;t magical, at least not any more magical than any other valid value.</p>

<p>If we need a truly unique value for our default state, we need to invent our own.</p>

<p>When <code>None</code> isn&rsquo;t a valid input for your function, it&rsquo;s perfectly fine to use it to represent a unique default or initial state.
But <code>None</code> is often valid data, which means <strong><code>None</code> is sometimes a poor choice for a unique initial state</strong>.</p>

<p>We&rsquo;ll fix both of our bugs by using <code>object()</code>: a somewhat common convention for creating a truly unique value in Python.</p>

<p>First we&rsquo;ll set <code>minimum</code> to a unique object:</p>

<pre><code class="python">def min(iterable, default=None):
    """Imperfect re-implementation of Python's built-in min function."""
    initial = object()
    minimum = initial
    for item in iterable:
        if minimum is initial or item &lt; minimum:
            minimum = item
    if minimum is not initial:
        return minimum
    elif default is not None:
        return default
    else:
        raise ValueError("Empty iterable")
</code></pre>

<p>That <code>initial</code> variable holds our unique value so we can check for its presence later.</p>

<p>This fixes the first bug:</p>

<pre><code class="python">&gt;&gt;&gt; min([None], default=0)
&gt;&gt;&gt; min([None])
&gt;&gt;&gt; min([])
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 13, in min
ValueError: Empty iterable
</code></pre>

<p>But not the second.</p>

<p>To fix the second bug we need to use a different default value for our <code>default</code> argument (other than <code>None</code>).</p>

<p>To do this, we&rsquo;ll make a global &ldquo;constant&rdquo; (by convention) variable, <code>INITIAL</code>, outside our function:</p>

<pre><code class="python">INITIAL = object()


def min(iterable, default=INITIAL):
    """Imperfect re-implementation of Python's built-in min function."""
    minimum = INITIAL
    for item in iterable:
        if minimum is INITIAL or item &lt; minimum:
            minimum = item
    if minimum is not INITIAL:
        return minimum
    elif default is not INITIAL:
        return default
    else:
        raise ValueError("Empty iterable")
</code></pre>

<p>Now our code works exactly how we&rsquo;d hope it would:</p>

<pre><code class="python">&gt;&gt;&gt; min([None], default=0)
&gt;&gt;&gt; min([None])
&gt;&gt;&gt; min([], default=None)
&gt;&gt;&gt; min([], default='')
''
&gt;&gt;&gt; min([4, 3, 7, 8])
3
&gt;&gt;&gt; min([4, 3, 7, 8], default=0)
3
&gt;&gt;&gt; min([])
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "&lt;stdin&gt;", line 12, in min
ValueError: Empty iterable
</code></pre>

<p>That&rsquo;s lovely&hellip; but what is this magical <code>object()</code> thing?
Why does it work, how does it work, and when should we use it?</p>

<h2>What is <code>object()</code>?</h2>

<p>Every class in Python has a base class of <code>object</code> (in Python 3 that is&hellip; things were a bit weirder in Python 2).</p>

<p>So <code>object</code> is a class:</p>

<pre><code class="python">&gt;&gt;&gt; object
&lt;class 'object'&gt;
&gt;&gt;&gt; type(object)
&lt;class 'type'&gt;
</code></pre>

<p>When we call <code>object</code> we&rsquo;re creating an &ldquo;instance&rdquo; of the object class, just as calling any other class (when given the correct arguments) will create instances of them:</p>

<pre><code class="python">&gt;&gt;&gt; set()
set()
&gt;&gt;&gt; bytearray()
bytearray(b'')
&gt;&gt;&gt; frozenset()
frozenset()
</code></pre>

<p>So we&rsquo;re creating an instance of <code>object</code>.
But&hellip; why?</p>

<p>Well, an instance of <code>object</code> shouldn&rsquo;t be seen as equal to any other object:</p>

<pre><code class="python">&gt;&gt;&gt; x = object()
&gt;&gt;&gt; y = object()
&gt;&gt;&gt; x == y
False
&gt;&gt;&gt; x == 4
False
&gt;&gt;&gt; x == None
False
&gt;&gt;&gt; x == []
False
</code></pre>

<p>Except itself:</p>

<pre><code class="python">&gt;&gt;&gt; x = object()
&gt;&gt;&gt; z = x
&gt;&gt;&gt; x == z
True
</code></pre>

<p>Python&rsquo;s <code>None</code> is similar, except that <em>anyone</em> can get access to this unique <code>None</code> object anywhere in their code by just typing <code>None</code>.</p>

<pre><code class="python">&gt;&gt;&gt; x = None
&gt;&gt;&gt; y = None
&gt;&gt;&gt; x == y
True
&gt;&gt;&gt; x = object()
&gt;&gt;&gt; y = object()
&gt;&gt;&gt; x == y
False
</code></pre>

<p>We needed a placeholder value in our code.
<code>None</code> is a lovely placeholder as long as <strong>we don&rsquo;t need to worry about distinguishing between <em>our</em> <code>None</code> and <em>their</em> <code>None</code></strong>.</p>

<p>If <code>None</code> is valid <em>data</em>, it&rsquo;s no longer just a placeholder.
At that point, we need to start reaching for <code>object()</code> instead.</p>

<h2>Equality vs identity</h2>

<p>I noted that <code>object()</code> isn&rsquo;t <em>equal</em> to anything else.
But we weren&rsquo;t actually checking for equality (using <code>==</code> or <code>!=</code>) in our function:</p>

<p>Instead of <code>==</code> and <code>!=</code>, we used <code>is</code> and <code>is not</code>.</p>

<pre><code class="python">INITIAL = object()


def min(iterable, default=INITIAL):
    """Imperfect re-implementation of Python's built-in min function."""
    minimum = INITIAL
    for item in iterable:
        if minimum is INITIAL or item &lt; minimum:
            minimum = item
    if minimum is not INITIAL:
        return minimum
    elif default is not INITIAL:
        return default
    else:
        raise ValueError("Empty iterable")
</code></pre>

<p>While <code>==</code> and <code>!=</code> are equality operators, <code>is</code> and <code>is not</code> are <strong>identity operators</strong>.</p>

<p>Python&rsquo;s <code>is</code> operator asks about the <strong>identity</strong> of an object: are the two objects on either side of the <code>is</code> operator actually the same exact object.</p>

<p>We&rsquo;re not just asking <em>are they equal</em>, but are they stored in <em>the same place in memory</em> and in fact refer to the same exact object.</p>

<p>Two of the variables below (<code>x</code> and <code>z</code>) point to the same object:</p>

<pre><code class="python">&gt;&gt;&gt; x = object()
&gt;&gt;&gt; y = object()
&gt;&gt;&gt; z = x
</code></pre>

<p>So while <code>y</code> has a unique ID in memory, <code>x</code> and <code>z</code> do not:</p>

<pre><code class="python">&gt;&gt;&gt; id(x)
140079600030400
&gt;&gt;&gt; id(y)
140079561403808
&gt;&gt;&gt; id(z)
140079600030400
</code></pre>

<p>Which means <code>x</code> is <em>identical</em> to <code>z</code>:</p>

<pre><code class="python">&gt;&gt;&gt; x is y
False
&gt;&gt;&gt; x is z
True
</code></pre>

<p>By default, Python&rsquo;s <code>==</code> operator delegates to <code>is</code>.
Meaning unless two variables point to the exact some object in memory, <code>==</code> will return <code>False</code>:</p>

<pre><code class="python">&gt;&gt;&gt; x = object()
&gt;&gt;&gt; y = object()
&gt;&gt;&gt; z = x
&gt;&gt;&gt; x == x
True
&gt;&gt;&gt; x == y
False
&gt;&gt;&gt; x == z
True
</code></pre>

<p>This is true <em>by default</em>&hellip; but many objects in Python overload the <code>==</code> operator to do much more useful things when we ask about equality.</p>

<pre><code class="python">&gt;&gt;&gt; 0 == 0.0
True
&gt;&gt;&gt; [1, 2, 3] == [1, 2, 3]
True
&gt;&gt;&gt; (1, 2) == (1, 3)
False
&gt;&gt;&gt; {} == {}
True
</code></pre>

<p>Each object can <strong>customize the behavior of <code>==</code></strong> to answer whatever question they&rsquo;d like.</p>

<p>Which means someone could make a class like this:</p>

<pre><code class="python">&gt;&gt;&gt; class AlwaysEqual:
...     def __eq__(self, other):
...         return True
...
</code></pre>

<p>And suddenly our assumption about <code>==</code> with <code>object()</code> (or any other value) will fail us:</p>

<pre><code class="python">&gt;&gt;&gt; x = object()
&gt;&gt;&gt; y = AlwaysEqual()
&gt;&gt;&gt; x is y
False
&gt;&gt;&gt; x == y
True
</code></pre>

<h2>Use identity to compare unique objects</h2>

<p>The <code>is</code> operator, unlike <code>==</code>, is not overloadable.
<strong>Unlike with <code>==</code>, there&rsquo;s no way to control or change what happens when you say <code>x is y</code>.</strong></p>

<p>There&rsquo;s a <code>__eq__</code> method, but there&rsquo;s no such thing as a <code>__is__</code> method.
Which means the <code>is</code> operator will never lie to you: it will always tell you whether two objects are one in the same.</p>

<p>If we use <code>is</code> instead of <code>==</code>, we could actually use any unique object to represent our unique <code>INITIAL</code> value.</p>

<p>Even an empty list:</p>

<pre><code class="python">INITIAL = []


def min(iterable, default=INITIAL):
    """Imperfect re-implementation of Python's built-in min function."""
    minimum = INITIAL
    for item in iterable:
        if minimum is INITIAL or item &lt; minimum:
            minimum = item
    if minimum is not INITIAL:
        return minimum
    elif default is not INITIAL:
        return default
    else:
        raise ValueError("Empty iterable")
</code></pre>

<p>An empty list might seem problematic in the same way as <code>None</code> was: but they&rsquo;re actually quite different.</p>

<p>We don&rsquo;t have any of the same issues as we did with <code>None</code> before:</p>

<pre><code class="python">&gt;&gt;&gt; min([[]], default=0)
[]
&gt;&gt;&gt; min([[]])
[]
&gt;&gt;&gt; min([], default=[])
[]
</code></pre>

<p>The reason is that <code>None</code> is a <a href="https://en.wikipedia.org/wiki/Singleton_pattern">singleton value</a>.
That means that whenever you say <code>None</code> in your Python code, you&rsquo;re referencing the exact same <code>None</code> object every time.</p>

<pre><code class="python">&gt;&gt;&gt; x = None
&gt;&gt;&gt; y = None
&gt;&gt;&gt; x is y
True
&gt;&gt;&gt; id(x), id(y)
(94548887510464, 94548887510464)
</code></pre>

<p>Whereas every empty list we make creates a brand new list object:</p>

<pre><code class="python">&gt;&gt;&gt; x = []
&gt;&gt;&gt; y = []
&gt;&gt;&gt; x is y
False
&gt;&gt;&gt; id(x), id(y)
(140079561624776, 140079598927432)
</code></pre>

<p>So while two independent empty lists may be <em>equal</em>, they aren&rsquo;t the same object:</p>

<pre><code class="python">&gt;&gt;&gt; x = []
&gt;&gt;&gt; y = []
&gt;&gt;&gt; x == y
True
&gt;&gt;&gt; x is y
False
</code></pre>

<p>The objects that those <code>x</code> and <code>y</code> variables point to have <strong>the same value</strong> but are <strong>not actually the same object</strong>.</p>

<h2>None is a placeholder value</h2>

<p>Python&rsquo;s <code>None</code> is lovely.
<code>None</code> is a universal placeholder value.
Need a placeholder?
Great!
Python has a great placeholder value and it&rsquo;s called <code>None</code>!</p>

<p>There are lots of places where Python itself actually uses <code>None</code> as a placeholder value also.</p>

<p>If you pass no arguments to the string <code>split</code> method, that&rsquo;s the same as passing a separator value of <code>None</code>:</p>

<pre><code class="python">&gt;&gt;&gt; s = "hello world"
&gt;&gt;&gt; s.split()
['hello', 'world']
&gt;&gt;&gt; s.split(None)
['hello', 'world']
</code></pre>

<p>If you pass in a <code>key</code> function of <code>None</code> to the <code>sorted</code> builtin, that&rsquo;s the same as passing in no <code>key</code> function at all:</p>

<pre><code class="python">&gt;&gt;&gt; sorted(s, key=None)
[' ', 'd', 'e', 'h', 'l', 'l', 'l', 'o', 'o', 'r', 'w']
&gt;&gt;&gt; sorted(s)
[' ', 'd', 'e', 'h', 'l', 'l', 'l', 'o', 'o', 'r', 'w']
</code></pre>

<p>Python loves using <code>None</code> as a placeholder because it&rsquo;s often a pretty great placeholder value.</p>

<p>The issue with <code>None</code> only appears <strong>if someone else could reasonably be using <code>None</code> as a non-placeholder input to our function</strong>.
This is often the case when the caller of a function has a placeholder values (often <code>None</code>) in their inputs and the author of that function (that&rsquo;s us) needs a separate unique placeholder.</p>

<p>Using <code>None</code> to represent two different things at once is like having two identical-looking bookmarks in the same book: it&rsquo;s confusing!</p>

<h2>Creating unique non-None placeholders: why <code>object()</code>?</h2>

<p>When we made that <code>INITIAL</code> value before, we were sort of inventing our own <code>None</code>-like object: an object that we could uniquely reference by using the <code>is</code> operator.</p>

<p>That <code>INITIAL</code> object we made should be completely unique: it shouldn&rsquo;t ever be seen in any arbitrary input that may be given to our function (unless someone made the strange decision to import <code>INITIAL</code> and reference it specifically).</p>

<p>Why <code>object()</code> though?
After all we could have used any unique object by creating an instance of pretty much any class:</p>

<pre><code class="python">&gt;&gt;&gt; INITIAL = []
&gt;&gt;&gt; INITIAL == []
True
&gt;&gt;&gt; INITIAL is []
False
</code></pre>

<p>Though it might have been even more clear to create our own class just for this purpose:</p>

<pre><code class="python">class DummyClass:
    """Class that just creates unique objects."""

INITIAL = DummyClass()
</code></pre>

<p>But I&rsquo;d argue that <code>object()</code> is the &ldquo;right&rdquo; thing to use here.</p>

<p>Everyone knows what <code>[]</code> means, but <code>object()</code> is mysterious, which is actually the reason I think it&rsquo;s a good choice in this case.</p>

<p>When we see an empty list we expect that list to be used <em>as a list</em> and when we see a class instance, we expect that class to <em>do something</em>.
But we don&rsquo;t actually want this object to <em>do</em> anything: <strong>we only care about the uniqueness of this new object</strong>.</p>

<p>We could have done this:</p>

<pre><code class="python">&gt;&gt;&gt; INITIAL = ['completely unique value']
</code></pre>

<p>But I find using <code>object()</code> less confusing than this because it&rsquo;s clear: readers won&rsquo;t have a chance to be confused by the listy-ness of a list.</p>

<pre><code class="python">&gt;&gt;&gt; INITIAL = object()  # completely unique value
</code></pre>

<p>Also if a confused developer Googles &ldquo;what is <code>object()</code> in Python?&rdquo; they might end up with <a href="https://stackoverflow.com/questions/28306371/what-is-object-good-for">some sort of explanation</a>.</p>

<h2>Other cases for non-None placeholders</h2>

<p>There&rsquo;s a word I&rsquo;ve been avoiding using up to this point.
I&rsquo;ve only been avoiding it because I think I typically misuse it (or rather overuse it).
The word is <a href="https://en.wikipedia.org/wiki/Sentinel_value">sentinel value</a>.</p>

<p>I suspect I overuse this word because I use it to mean any unique placeholder value, such as the <code>INITIAL</code> object we made before.
But most definitions I&rsquo;ve seen use &ldquo;sentinel value&rdquo; to specifically mean a value which indicates the end of a list, a loop, or an algorithm.</p>

<p>Sentinel values are a thing that, when seen, indicate that something has finished.
I think of this as a <strong>stop value</strong>: when you see a sentinel value it&rsquo;s a signal that the loop or algorithm that you&rsquo;re in should terminate.</p>

<p>Before we weren&rsquo;t using a stop value so much as an <strong>initial value</strong>.</p>

<p>Here&rsquo;s an example of a stop value; a true sentinel value:</p>

<pre><code class="python">from itertools import zip_longest

SENTINEL = object()

def strict_zip(*iterables):
    """Variation of ``zip`` which requires equal-length iterables."""
    for values in zip_longest(*iterables, fillvalue=SENTINEL):
        if SENTINEL in values:
            raise ValueError("Given iterables must have the same length.")
        yield values
</code></pre>

<p>We&rsquo;re using the unique <code>SENTINEL</code> value above to signal that we need to stop looping and raise an exception.
The presence of this value indicates that one of our iterables was a different length than the others and we need to handle this error case.</p>

<h2>Rely on identity checks for unique values</h2>

<p>Note that we&rsquo;re implicitly relying on <code>==</code> above because we&rsquo;re saying <code>if SENTINEL in values</code> which actually loops over <code>values</code> looking for a value that is equal to <code>SENTINEL</code>.</p>

<p>If we wanted to be more strict (and possibly more efficient) we could rely on <code>is</code>, but we&rsquo;d need to do some looping ourselves.
Fortunately Python&rsquo;s <code>any</code> function and a generator expression would make that a bit easier:</p>

<pre><code class="python">from itertools import zip_longest

SENTINEL = object()

def strict_zip(*iterables):
    """Variation of ``zip`` which requires equal-length iterables."""
    for values in zip_longest(*iterables, fillvalue=SENTINEL):
        if any(v is SENTINEL for v in values):
            raise ValueError("Given iterables must have the same length.")
        yield values
</code></pre>

<p>I&rsquo;m fine with either of these functions.  The first is a bit more readable even though this one is arguably a bit more correct.</p>

<p>Identity checks are often faster than equality checks (<code>==</code> has to call the <code>__eq__</code> method, but <code>is</code> does a straight memory ID check).
But identity checks are also a bit more <em>correct</em>: if it&rsquo;s uniqueness we care about, <strong>a unique memory location is the ultimate uniqueness check</strong>.</p>

<p>When writing code that uses <strong>a unique object</strong>, it&rsquo;s wise to <strong>rely on identity rather than equality</strong> if you can.</p>

<h2>This is what <code>is</code> was made for</h2>

<p>If we care about <em>equality</em> (the value of an object) we use <code>==</code>, if we care about <em>identity</em> (the memory location) we use <code>is</code>.</p>

<p>If you search my Python code for <code>is</code> you&rsquo;ll pretty much only find the following things:</p>

<ol>
<li><code>x is None</code> (this is the most common thing you&rsquo;ll see)</li>
<li><code>x is True</code> or <code>x is False</code> (sometimes my tests get picky about <code>True</code> vs truthiness)</li>
<li><code>iter(x) is x</code> (<a href="https://treyhunner.com/2016/12/python-iterator-protocol-how-for-loops-work/">iterators</a> are a different Python rabbit hole)</li>
<li><code>x is some_unique_object</code></li>
</ol>


<p>Those first two are checking for a <a href="https://en.wikipedia.org/wiki/Singleton_pattern">singleton</a> value (as <a href="https://pep8.org/#programming-recommendations">recommended by PEP 8</a>).
The third one is checking if we&rsquo;ve seen <strong>the same object twice</strong> (an iterator in this case).
And the fourth one is checking for the presence of these unique values we&rsquo;ve been discussing.</p>

<p>The <code>is</code> operator checks whether two objects are exactly the same object in memory.
<strong>You never want to use the <code>is</code> operator <em>except</em> for true identity checks</strong>: <a href="https://en.wikipedia.org/wiki/Singleton_pattern">singletons</a> (like <code>None</code>, <code>True</code>, and <code>False</code>), checking for the same object again, and checking for our own unique values (sentinels, as I usually call them).</p>

<h2>So when would we use <code>object()</code>?</h2>

<p>Oftentimes <code>None</code> is both the easy answer and the right answer for a unique placeholder value in Python, but sometimes you just need to invent your own unique placeholder value.
In those cases <code>object()</code> is a great tool to have in your Python toolbox.</p>

<p>When would we actually use <code>object()</code> for a uniqueness check in our own code?</p>

<p>I can think of a few cases:</p>

<ol>
<li><strong>Unique initial values</strong>: a starting value that should be distinguished from values seen later (<code>default</code> and <code>initial</code> in our <code>min</code> function)</li>
<li><strong>Unique stop values</strong>: a value whose presence tells us to stop looping/processing (a true sentinel value, as in <code>strict_zip</code>)</li>
<li><strong>Unique skip values</strong>: a value whose presence should be treated as an empty value to be skipped over (we didn&rsquo;t see this, but it comes up with utilities like <code>itertools.zip_longest</code> sometimes)</li>
</ol>


<p>I hope this meandering through unique values has given you something (some non-<code>None</code> things) to think about.</p>

<p>May your <code>None</code> values be unambiguous and your identity checks be truly unique.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tuple ordering and deep comparisons in Python]]></title>
    <link href="http://treyhunner.com/2019/03/python-deep-comparisons-and-code-readability/"/>
    <updated>2019-03-13T07:30:00-07:00</updated>
    <id>http://treyhunner.com/2019/03/python-deep-comparisons-and-code-readability</id>
    <content type="html"><![CDATA[<p>Comparing things in Python.
That sounds like something that almost doesn&rsquo;t even need to be taught.
But I&rsquo;ve found that <strong>Python&rsquo;s comparison operators are often misunderstood and under-appreciated by newer Pythonistas</strong>.</p>

<p>Let&rsquo;s review how Python&rsquo;s comparison operators work on different types of objects and then take a look at how we can use this to improve the readability of our code.</p>

<h2>Python&rsquo;s comparison operators</h2>

<p>By &ldquo;comparison operators&rdquo; I mean the equality operators (<code>==</code> and <code>!=</code>) and the ordering operators (<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>).</p>

<p>We can use these operators to compare numbers, as you&rsquo;d expect:</p>

<pre><code class="python">&gt;&gt;&gt; 3 == 4
False
&gt;&gt;&gt; 3 != 4
True
&gt;&gt;&gt; 3 &lt; 4
True
&gt;&gt;&gt; 3 &gt; 4
False
</code></pre>

<p>But we can also use these operators to compare strings:</p>

<pre><code class="python">&gt;&gt;&gt; "pear" == "pickle"
False
&gt;&gt;&gt; "pear" != "pickle"
True
&gt;&gt;&gt; "pear" &lt; "pickle"
True
&gt;&gt;&gt; "pear" &gt; "pickle"
False
</code></pre>

<p>And even tuples:</p>

<pre><code class="python">&gt;&gt;&gt; target = (3, 6, 2)
&gt;&gt;&gt; installed = (3, 7, 0)
&gt;&gt;&gt; target == installed
False
&gt;&gt;&gt; target &lt;= installed
True
&gt;&gt;&gt; target &gt; installed
False
</code></pre>

<p>Many programming languages don&rsquo;t have an equivalent to Python&rsquo;s very flexible comparison operators.</p>

<p>We&rsquo;ll take a look at how these operators work on tuples and more complex objects in a moment, but we&rsquo;ll start with something simpler: string comparisons.</p>

<h2>String comparisons in Python</h2>

<p>Equality and inequality with strings is fairly simple.
If two strings have exactly the same characters, they&rsquo;re equal:</p>

<pre><code class="python">&gt;&gt;&gt; "hello" == "hello"
True
&gt;&gt;&gt; "hello" == "hella"
False
</code></pre>

<p>Note that I&rsquo;m glossing over a very big exception: unicode characters.
There are often multiple ways to represent the same text and those different representations must be <a href="https://docs.python.org/3/library/unicodedata.html#unicodedata.normalize">normalized</a> before they&rsquo;re seen as equal.
For simplicity, we&rsquo;re going to stick to ASCII characters in this article.</p>

<p>Ordering of strings is where things get a bit interesting in Python:</p>

<pre><code class="python">&gt;&gt;&gt; "pickle" &lt; "python"
True
</code></pre>

<p>The string <code>"pickle"</code> is <em>less than</em> the string <code>"python"</code> because we&rsquo;re ordering alphabetically&hellip; sort of.
Capitalization matters:</p>

<pre><code class="python">&gt;&gt;&gt; "pickle" &lt; "Python"
False
</code></pre>

<p>The string <code>"Python"</code> is less than <code>"pickle"</code> because <code>P</code> is less than <code>p</code>.</p>

<p>We&rsquo;re not actually ordering alphabetically here so much as <strong>ASCII-betically</strong> (unicode-betically really since we&rsquo;re in Python 3).
These strings are being ordered by the ASCII values of their characters (<code>p</code> is 112 in <a href="https://en.wikipedia.org/wiki/ASCII#Printable_characters">ASCII</a> and <code>P</code> is 80).</p>

<pre><code class="python">&gt;&gt;&gt; ord("p")
112
&gt;&gt;&gt; ord("P")
80
&gt;&gt;&gt; "P" &lt; "p"
True
</code></pre>

<p>Technically Python compares the Unicode code point (which is what <a href="https://docs.python.org/3/library/functions.html#ord">ord</a> does) for these characters and that happens to be the same as the ASCII value for ASCII characters.</p>

<p>The rules for ordering strings are:</p>

<ol>
<li>Compare the n-th characters of each string (starting with the first character, index <code>0</code>) using the <code>==</code> operator; if they&rsquo;re equal, repeat this step with the next character</li>
<li>For two unequal characters, take the character that has the lower code point and declare its string &ldquo;less than&rdquo; the other</li>
<li>If all characters are equal, the strings are equal</li>
<li>If one string runs out of characters during step 1 (one string is a &ldquo;prefix&rdquo; of the other), the shorter string is &ldquo;less than&rdquo; the longer one</li>
</ol>


<p>The ordering algorithm Python uses for strings might seem complicated, but it&rsquo;s <strong>very similar to the ordering algorithm used in dictionaries</strong>; not Python dictionaries but <a href="https://en.wikipedia.org/wiki/Dictionary">physical dictionaries</a> (those things we used before the Internet existed).
We give precedence to the first characters when ordering words in dictionaries and if one word is a prefix of another, it comes first.</p>

<h2>Tuple comparisons</h2>

<p>We can ask tuples if they&rsquo;re equal, just as we can ask strings if they&rsquo;re equal:</p>

<pre><code class="python">&gt;&gt;&gt; (3, 6, 2) == (3, 6, 2)
True
&gt;&gt;&gt; (3, 6, 2) == (3, 7, 0)
False
</code></pre>

<p>But we can also compare tuples using the ordering operators (<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>):</p>

<pre><code class="python">&gt;&gt;&gt; (3, 6, 2) &lt; (3, 6, 2)
False
&gt;&gt;&gt; (3, 6, 2) &lt;= (3, 6, 2)
True
&gt;&gt;&gt; (3, 6, 2) &lt; (3, 7, 0)
True
&gt;&gt;&gt; (3, 6, 2) &gt;= (3, 7, 0)
False
</code></pre>

<p>String ordering might have been somewhat intuitive (most of us learned alphabetical ordering before Python), but tuple ordering doesn&rsquo;t often feel quite as intuitive at first.
But you&rsquo;re actually somewhat familiar with tuple ordering already because <strong>tuple ordering uses the same algorithm as string ordering</strong>.</p>

<p>The rules for ordering tuples (which are essentially the same as ordering strings):</p>

<ol>
<li>Compare the n-th items of each tuple (starting with the first, index <code>0</code>) using the <code>==</code> operator; if they&rsquo;re equal, repeat this step with the next item</li>
<li>For two unequal items, the item that is &ldquo;less than&rdquo; makes the tuple that contains it also &ldquo;less than&rdquo; the other tuple</li>
<li>If all items are equal, the tuples are equal</li>
<li>If one tuple runs out of items during step 1 (one tuple is a &ldquo;prefix&rdquo; of the other), the shorter tuple is &ldquo;less than&rdquo; the longer one</li>
</ol>


<p>In Python, this algorithm might look sort of like this:</p>

<pre><code class="python">def less_than(tuple1, tuple2):
    for x, y in zip(tuple1, tuple2):
        if x == y:
            continue
        return (x &lt; y)
    if len(tuple1) &lt; len(tuple2):
        return True  # There were more items in the second tuple
    else:
        return False  # The first tuple had more items or they are equal
</code></pre>

<p>Note that we&rsquo;d never write code like this because Python is doing all this work for us already.
That whole function is the same as using the <code>&lt;</code> operator:</p>

<pre><code class="python">def less_than(tuple1, tuple2):
    return tuple1 &lt; tuple2
</code></pre>

<h2>Lexicographical ordering</h2>

<p>This <strong>alphabetical-like style of ordering</strong> that gives precedence to the first items in an iterable is called <a href="https://en.wikipedia.org/wiki/Lexicographical_order">lexicographical ordering</a>.
You don&rsquo;t need to know that phrase, but if you ever need to describe <em>the way ordering works in Python</em>, <strong>lexicographical</strong> is the word to use.</p>

<p>Strings and tuples are ordered lexicographically, as we&rsquo;ve seen, but so are lists:</p>

<pre><code class="python">&gt;&gt;&gt; [1, 2, 3] &lt; [1, 4]
True
&gt;&gt;&gt; [1, 2, 3] &lt; [1, 2, 2]
False
</code></pre>

<p>In fact, most <a href="https://docs.python.org/3/glossary.html#term-sequence">sequences</a> in Python <a href="https://docs.python.org/3/tutorial/datastructures.html#comparing-sequences-and-other-types">should be ordered lexicographically</a> (<code>range</code> objects are an exception to this as they can&rsquo;t be ordered at all).</p>

<p>But not every collection in Python relies on lexicographical ordering.</p>

<h2>Dictionary and set comparisons</h2>

<p>Many objects in Python work with equality but don&rsquo;t work with ordering at all.</p>

<p>For example dictionaries compare &ldquo;equal&rdquo; when they have all the same keys and values:</p>

<pre><code class="python">&gt;&gt;&gt; expected = {'name': 'Trey', 'python_version': 3.7.0}
&gt;&gt;&gt; actual = {'name': 'Trey', 'python_version': 2.7.0}
&gt;&gt;&gt; expected == actual
False
&gt;&gt;&gt; actual['python_version'] = 3.7.0
&gt;&gt;&gt; expected == actual
True
</code></pre>

<p>But <strong>dictionaries can&rsquo;t be ordered</strong> using the <code>&lt;</code> or <code>&gt;</code> operators:</p>

<pre><code class="python">&gt;&gt;&gt; expected &lt; actual
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: '&lt;' not supported between instances of 'dict' and 'dict'
</code></pre>

<p>Sets are similar, except that sets <em>do</em> work with ordering operators&hellip; they just don&rsquo;t use those operators for ordering:</p>

<pre><code class="python">&gt;&gt;&gt; {1, 2} &lt; {1, 2, 3}
True
&gt;&gt;&gt; {1, 3} &lt; {1, 2, 4}
False
</code></pre>

<p>Sets overload these operators to answer questions about <strong>whether one set is a subset or superset of another</strong> (<a href="https://docs.python.org/3.7/library/stdtypes.html#set-types-set-frozenset">see sets in the documentation</a>).</p>

<h2>Deep equality</h2>

<p>Comparisons between two data structures in Python tend to be <strong>deep comparisons</strong>.
Whether we&rsquo;re comparing lists, tuples, sets, or dictionaries, when we ask whether two of these objects are &ldquo;equal&rdquo; Python will recurse through each sub-object and ask whether each is &ldquo;equal&rdquo;.</p>

<p>So given a dictionary that maps tuples to lists of tuples:</p>

<pre><code class="python">&gt;&gt;&gt; current_portals = {(1, 2): [(2, 1)], (2, 1): [(1, 2), (3, 4)]}
&gt;&gt;&gt; previous_portals = {(1, 2): [(2, 1)], (2, 1): [(1, 2)]}
</code></pre>

<p>Asking whether these two dictionaries are equal is equivalent to asking whether each key-value pair is equal, recursively:</p>

<pre><code class="python">&gt;&gt;&gt; current_portals == previous_portals
False
&gt;&gt;&gt; current_portals[2, 1].pop()
(3, 4)
&gt;&gt;&gt; current_portals == previous_portals
True
</code></pre>

<p>The dictionaries ask each of their keys &ldquo;are you in the other dictionary&rdquo; and then asks each of the corresponding values for those keys &ldquo;are you equal to the other value&rdquo;.
But each of these operations may (as in this case) require another level of depth: the keys are tuples which need to be traversed and the values are lists which need to be traversed.
And in this case those values, the lists, need to be traversed even deeper because they contain more data structures: tuples.</p>

<p><strong>We don&rsquo;t have to worry about any of this though</strong>: Python just does these deep comparisons for us automatically.</p>

<p>While you don&rsquo;t need to worry about how deep comparisons work, the fact that Python&rsquo;s comparisons <em>are</em> deep can be pretty handy to know.</p>

<p>For example if we have <a href="https://pastebin.com/raw/yspKmfyj">a class</a> with <code>x</code>, <code>y</code>, and <code>z</code> attributes we&rsquo;d like to compare in our <code>__eq__</code> method, instead of this long boolean expression:</p>

<pre><code class="python">def __eq__(self, other):
    return self.x == other.x and self.y == other.y and self.z == other.z
</code></pre>

<p>We could bundle these values into 3-item tuples and compare them that way instead:</p>

<pre><code class="python">def __eq__(self, other):
    return (self.x, self.y, self.z) == (other.x, other.y, other.z)
</code></pre>

<p>I find this more readable, mostly because <strong>we&rsquo;ve added symmetry to our code</strong>: we have one <code>==</code> expression with the same kind of object on each side of it.</p>

<h2>Deep ordering</h2>

<p>This &ldquo;deep comparison&rdquo; works for equality, but it also works for ordering.</p>

<p>The use case for deep ordering isn&rsquo;t as obvious as for deep equality, but identifying places where deep ordering is handy can help you drastically improve the readability of your code.</p>

<p>Take this example method:</p>

<pre><code class="python">def __lt__(self, other):
    if self.last_name &lt; other.last_name:
        return True
    elif other.last_name &lt; self.last_name:
        return False
    elif self.first_name &lt; other.first_name:
        return True
    else:
        return False
</code></pre>

<p>This <code>__lt__</code> method implements the <code>&lt;</code> operator on <a href="https://pastebin.com/raw/u8uGDArq">its class</a>, returning <code>True</code> if <code>self</code> is less than <code>other</code>.
Storing and comparing <code>first_name</code> and <code>last_name</code> attributes this way is <a href="https://www.youtube.com/watch?v=458KmAKq0bQ&amp;feature=youtu.be&amp;t=148">an anti-pattern</a> but we&rsquo;ll ignore that fact for this example.</p>

<p>That <code>__lt__</code> method above gives precedence to the <code>last_name</code>: the <code>first_name</code> is only checked if the <code>last_name</code> attribute of these two objects happens to be equal.</p>

<p>If we wanted to collapse this logic some, we could rewrite our code like this:</p>

<pre><code class="python">def __lt__(self, other):
    return (
        self.last_name &lt; other.last_name or
        self.last_name == other.last_name and self.first_name &lt; other.first_name
    )
</code></pre>

<p>Or&hellip; we could rely on the deep ordering of tuples instead:</p>

<pre><code class="python">def __lt__(self, other):
    return (self.last_name, self.first_name) &lt; (other.last_name, other.first_name)
</code></pre>

<p>Here we&rsquo;re ordering our tuples lexicographically (by their first item first).
Our tuples happen to contain strings, which are also ordered lexicographically (by their first character first).
So we&rsquo;re <strong>deeply ordering</strong> these objects.</p>

<h2>Sorting by multiple attributes at once</h2>

<p>Knowing about lexicographical ordering and deep ordering of Python sequences can be quite useful when sorting Python objects.
From Python&rsquo;s perspective, <strong>sorting is really just ordering over and over</strong>.</p>

<p>Python&rsquo;s built-in <code>sorted</code> function accepts a <code>key</code> function which can return a corresponding key object to sort each of these items by.</p>

<p>Here we&rsquo;re specifying a <code>key</code> function that accepts a word and returns a tuple of two things: the length of the word and the case-normalized word:</p>

<pre><code class="python">&gt;&gt;&gt; fruits = ['kumquat', 'Cherimoya', 'Loquat', 'longan', 'jujube']
&gt;&gt;&gt; def length_and_word(word): return (len(word), word.casefold())
...
&gt;&gt;&gt; sorted(fruits, key=length_and_word)
['jujube', 'longan', 'Loquat', 'kumquat', 'Cherimoya']
</code></pre>

<p>With the key function above we&rsquo;re able to sort fruits first by their length and <em>then</em> by their case-normalized equivalent.
So &ldquo;jujube&rdquo; comes first because it&rsquo;s 6 letters (like <code>longan</code> and <code>Loquat</code>) but it&rsquo;s also alphabetically before <code>longan</code> and <code>Loquat</code>.</p>

<p>If we just sorted by length we would have had a different ordering:</p>

<pre><code class="python">&gt;&gt;&gt; sorted(fruits, key=len)
['Loquat', 'longan', 'jujube', 'kumquat', 'Cherimoya']
</code></pre>

<p><strong>Slight aside</strong>: deep comparisons actually predate the <code>sorted</code> function&rsquo;s <code>key</code> argument in Python.
Before there was a key function Python developers would create lists of tuples, sort the lists of tuples, and then grab the actual value they cared about out of that list (which is <a href="https://docs.python.org/3/howto/sorting.html#the-old-way-using-decorate-sort-undecorate">discussed in the docs</a>).</p>

<p>The <code>sorted</code> function isn&rsquo;t the only place where tuple ordering can come in handy.
Any place where you see a <code>key</code> function might be a candidates for relying on tuple ordering.
For example the <code>min</code> and <code>max</code> functions:</p>

<pre><code>&gt;&gt;&gt; min(fruits, key=str.casefold)
'Cherimoya'
&gt;&gt;&gt; max(fruits, key=str.casefold)
'Loquat'
</code></pre>

<p>Anywhere Python does an ordering operation might be a place you could rely on the deep ordering of Python&rsquo;s data structures.</p>

<h2>Deep hashability (and unhashability)</h2>

<p>Python has both deep equality and deep orderability.
But Python&rsquo;s deep comparisons don&rsquo;t stop there: there&rsquo;s also deep hashability.</p>

<p>This is something that mostly comes up with tuples.
Tuples can be used as a key in a dictionary (as we saw earlier), and they can be used in sets:</p>

<pre><code class="python">&gt;&gt;&gt; current_portals = {(1, 2): [(2, 1)], (2, 1): [(1, 2), (3, 4)]}
&gt;&gt;&gt; points = {(1, 2), (2, 1), (3, 4)}
</code></pre>

<p>But this only works for tuples that contain immutable values:</p>

<pre><code class="python">&gt;&gt;&gt; things = {(["dress", "truck"], "yellow"), (["ball", "plane"], "purple")}
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unhashable type: 'list'
</code></pre>

<p>Tuples with lists in them aren&rsquo;t hashable because lists aren&rsquo;t hashable: each object inside a tuple must be hashable for the tuple itself to be hashable.</p>

<p>So while tuples containing lists aren&rsquo;t hashable, tuples containing tuples <em>are</em> hashable:</p>

<pre><code class="python">&gt;&gt;&gt; things = {(("dress", "truck"), "yellow"), (("ball", "plane"), "purple")}
&gt;&gt;&gt; things
{(('dress', 'truck'), 'yellow'), (('ball', 'plane'), 'purple')}
</code></pre>

<p>Tuples compute their hash values by delegating to the hash values of the items they contain:</p>

<pre><code class="python">&gt;&gt;&gt; x = (1, 2)
&gt;&gt;&gt; y = (1, 2)
&gt;&gt;&gt; hash(x)
3713081631934410656
&gt;&gt;&gt; hash(x) == hash(y)
True
</code></pre>

<p>While hashability is a big subject, this is really all I&rsquo;m going to say about it.
You don&rsquo;t really need to know how hashing works in Python so if you found this section confusing, that&rsquo;s okay!</p>

<p>The takeaway here is that Python supports <strong>deep hashability</strong> which is <strong>the reason we can use tuples as dictionary keys</strong> and the reason we can use tuples in sets.</p>

<h2>Deep comparisons are a tool to remember</h2>

<p>When you have code that compares two objects based on subparts in a particular order:</p>

<pre><code class="python">d1 = (1999, 12, 31)
d2 = (1999, 12, 1)
if d1[0] &gt; d2[0]:
    greater = d1
elif d1[0] &lt; d2[0]:
    greater = d2
elif d1[1] &gt; d2[1]:
    greater = d1
elif d1[1] &lt; d2[1]:
    greater = d2
elif d1[2] &gt; d2[2]:
    greater = d1
else:
    greater = d2
</code></pre>

<p>You could probably rely on tuple ordering instead:</p>

<pre><code class="python">d1 = (1999, 12, 31)
d2 = (1999, 12, 1)
if d1 &lt; d2:
    greater = d1
else:
    greater = d2
</code></pre>

<p>If you are comparing many different things as equal:</p>

<pre><code class="python">&gt;&gt;&gt; d1 = (1999, 12, 31)
&gt;&gt;&gt; d2 = (1999, 12, 1)
&gt;&gt;&gt; d1[0] == d2[0] and d1[1] == d2[1] and d1[2] == d2[2]
False
</code></pre>

<p>You could probably rely on deep equality instead:</p>

<pre><code class="python">&gt;&gt;&gt; d1 = (1999, 12, 31)
&gt;&gt;&gt; d2 = (1999, 12, 1)
&gt;&gt;&gt; d1 == d2
False
</code></pre>

<p>And if you need to use a dictionary that has a key made up of multiple parts, if those parts are each hashable, you could probably use a tuple:</p>

<pre><code class="python">&gt;&gt;&gt; points = {}
&gt;&gt;&gt; points[1, 2] = 'red'
&gt;&gt;&gt; points
{(1, 2): 'red'}
</code></pre>

<p><strong>Python&rsquo;s support for lexicographical ordering and deep comparisons is often overlooked by folks moving from other programming languages</strong>.
Remember these features: you may not need them today, but they&rsquo;ll almost certainly come in handy at some point.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[No really, pathlib is great]]></title>
    <link href="http://treyhunner.com/2019/01/no-really-pathlib-is-great/"/>
    <updated>2019-01-15T11:20:00-08:00</updated>
    <id>http://treyhunner.com/2019/01/no-really-pathlib-is-great</id>
    <content type="html"><![CDATA[<p>I recently <a href="https://treyhunner.com/2018/12/why-you-should-be-using-pathlib/">published an article about Python&rsquo;s pathlib module</a> and how I think everyone should be using it.</p>

<p>I won some <a href="https://docs.python.org/3/library/pathlib.html">pathlib</a> converts, but some folks also brought up concerns.
Some folks noted that I seemed to be comparing <code>pathlib</code> to <code>os.path</code> in a disingenuous way.
Some people were also concerned that <code>pathlib</code> will take a very long time to be widely adopted because <code>os.path</code> is so entrenched in the Python community.
And there were also concerns expressed about performance.</p>

<p>In this article I&rsquo;d like to acknowledge and address these concerns.
This will be both a defense of <code>pathlib</code> and a sort of love letter to <a href="https://www.python.org/dev/peps/pep-0519/#standard-library-changes">PEP 519</a>.</p>

<h2>Comparing pathlib and os.path the right way</h2>

<p>In my last article I compared this code which uses <code>os</code> and <code>os.path</code>:</p>

<pre><code class="python">import os
import os.path

os.makedirs(os.path.join('src', '__pypackages__'), exist_ok=True)
os.rename('.editorconfig', os.path.join('src', '.editorconfig'))
</code></pre>

<p>To this code with uses <code>pathlib.Path</code>:</p>

<pre><code class="python">from pathlib import Path

Path('src/__pypackages__').mkdir(parents=True, exist_ok=True)
Path('.editorconfig').rename('src/.editorconfig')
</code></pre>

<p>This might seem like an unfair comparison because I used <code>os.path.join</code> in the first example to ensure the correct path separator is used on all platforms but I didn&rsquo;t do that in the second example.
But this is in fact a fair comparison because <strong>the Path class normalizes path separators automatically</strong>.</p>

<p>We can prove this by looking at the string representation of this <code>Path</code> object on Windows:</p>

<pre><code class="pycon">&gt;&gt;&gt; str(Path('src/__pypackages__'))
'src\\__pypackages__'
</code></pre>

<p>No matter whether we use the <code>joinpath</code> method, a <code>/</code> in a path string, the <code>/</code> operator (which is a neat feature of <code>Path</code> objects), or separate arguments to the <code>Path</code> constructor, we get the same representation in all cases:</p>

<pre><code class="pycon">&gt;&gt;&gt; Path('src', '.editorconfig')
WindowsPath('src/.editorconfig')
&gt;&gt;&gt; Path('src') / '.editorconfig'
WindowsPath('src/.editorconfig')
&gt;&gt;&gt; Path('src').joinpath('.editorconfig')
WindowsPath('src/.editorconfig')
&gt;&gt;&gt; Path('src/.editorconfig')
WindowsPath('src/.editorconfig')
</code></pre>

<p>That last expression caused some confusion from folks who assumed <code>pathlib</code> wouldn&rsquo;t be smart enough to convert that <code>/</code> into a <code>\</code> in the path string.
Fortunately, it is!</p>

<p>With <code>Path</code> objects, you never have to worry about backslashes vs forward slashes again: specify all paths using forward slashes and you&rsquo;ll get what you&rsquo;d expect on all platforms.</p>

<h2>Normalizing file paths shouldn&rsquo;t be your concern</h2>

<p>If you&rsquo;re developing on Linux or Mac, it&rsquo;s very easy to add bugs to your code that only affect Windows users.
Unless you&rsquo;re careful to use <code>os.path.join</code> to build your paths up or <code>os.path.normcase</code> to convert forward slashes to backslashes as appropriate, <strong>you may be writing code that breaks on Windows</strong>.</p>

<p>This is a Windows bug waiting to happen (we&rsquo;ll get mixed backslashes and forward slashes here):</p>

<pre><code class="python">import sys
import os.path
directory = '.' if not sys.argv[1:] else sys.argv[1]
new_file = os.path.join(directory, 'new_package/__init__.py')
</code></pre>

<p>This just works on all systems:</p>

<pre><code class="python">import sys
from pathlib import Path
directory = '.' if not sys.argv[1:] else sys.argv[1]
new_file = Path(directory, 'new_package/__init__.py')
</code></pre>

<p>It used to be the responsibility of you the Python programmer to carefully join and normalize your paths, just as it used to be your responsibility in Python 2 land to use unicode whenever it was more appropriate than bytes.
This is the case no more.
The <code>pathlib.Path</code> class is careful to fix path separator issues before they even occur.</p>

<p>I don&rsquo;t use Windows.
I don&rsquo;t own a Windows machine.
But a ton of the developers who use my code likely use Windows and I don&rsquo;t want my code to break on their machines.</p>

<p><strong>If there&rsquo;s a chance that your Python code will ever run on a Windows machine, you really need <code>pathlib</code></strong>.</p>

<p><strong>Don&rsquo;t stress about path normalization</strong>: just use <code>pathlib.Path</code> whenever you need to represent a file path.</p>

<h2>pathlib seems great, but I depend on code that doesn&rsquo;t use it!</h2>

<p>You have lots of code that works with path strings.
Why would you switch to using <code>pathlib</code> when it means you&rsquo;d need to rewrite all this code?</p>

<p>Let&rsquo;s say you have a function like this:</p>

<pre><code class="python">import os
import os.path

def make_editorconfig(dir_path):
    """Create .editorconfig file in given directory and return filename."""
    filename = os.path.join(dir_path, '.editorconfig')
    if not os.path.exists(filename):
        os.makedirs(dir_path, exist_ok=True)
        open(filename, mode='wt').write('')
    return filename
</code></pre>

<p>This function accepts a directory to create a <code>.editorconfig</code> file in, like this:</p>

<pre><code class="pycon">&gt;&gt;&gt; import os.path
&gt;&gt;&gt; make_editorconfig(os.path.join('src', 'my_package'))
'src/my_package/.editorconfig'
</code></pre>

<p>But our code also works with a <code>Path</code> object:</p>

<pre><code class="pycon">&gt;&gt;&gt; from pathlib import Path
&gt;&gt;&gt; make_editorconfig(Path('src/my_package'))
'src/my_package/.editorconfig'
</code></pre>

<p>But&hellip; how??</p>

<p>Well <code>os.path.join</code> accepts <code>Path</code> objects (as of Python 3.6).
And <code>os.makedirs</code> accepts <code>Path</code> objects too.</p>

<p>In fact the built-in <code>open</code> function accepts <code>Path</code> objects and <code>shutil</code> does and anything in the standard library that previously accepted a path string is now expected to work with both <code>Path</code> objects and path strings.</p>

<p>This is all thanks to <a href="https://www.python.org/dev/peps/pep-0519/#standard-library-changes">PEP 519</a>, which called for an <code>os.PathLike</code> abstract base class and declared that Python utilities that work with file paths should now accept either path strings or path-like objects.</p>

<h2>But my favorite third-party library X has a better Path object!</h2>

<p>You might already be using a third-party library that has a <code>Path</code> object which works differently than pathlib&rsquo;s Path objects.
Maybe you even like it better.</p>

<p>For example <a href="https://github.com/joke2k/django-environ">django-environ</a>, <a href="https://github.com/jaraco/path.py">path.py</a>, <a href="https://github.com/tomerfiliba/plumbum">plumbum</a>, and <a href="https://github.com/saulpw/visidata">visidata</a> all have their own custom <code>Path</code> objects that represent file paths.
Some of these <code>pathlib</code> alternatives predate <code>pathlib</code> and chose to inherit from <code>str</code> so they could be passed to functions that expected path strings.
Thanks to PEP 519 both <code>pathlib</code> and its third-party alternatives can play nicely without needing to resort to the hack of inheriting from <code>str</code>.</p>

<p>Let&rsquo;s say you don&rsquo;t like <code>pathlib</code> because <code>Path</code> objects are immutable and you very much prefer using mutable <code>Path</code> objects.
Well thanks to <a href="https://www.python.org/dev/peps/pep-0519/#standard-library-changes">PEP 519</a>, you can create your own even-better-because-it-is-mutable <code>Path</code> and also has a <code>__fspath__</code>.
You don&rsquo;t <em>need</em> to use <code>pathlib</code> to benefit from it.</p>

<p>Any homegrown <code>Path</code> object you make or find in a third party library now has the ability to work natively with the Python built-ins and standard library modules that expect Path objects.
<strong>Even if you don&rsquo;t like <code>pathlib</code>, its existence a big win for third-party <code>Path</code> objects as well</strong>.</p>

<h2>But Path objects and path strings don&rsquo;t mix, do they?</h2>

<p>You might be thinking: this is really wonderful, but won&rsquo;t this sometimes-a-string and sometimes-a-path-object situation add confusion to my code?</p>

<p>The answer is yes, somewhat.
But I&rsquo;ve found that it&rsquo;s pretty easy to work around.</p>

<p>PEP 519 added a couple other things along with path-like objects: one is a way to convert all path-like objects to path strings and the other is a way to convert all path-like objects to <code>Path</code> objects.</p>

<p>Given either a path string or a <code>Path</code> object (or anything with a <code>__fspath__</code> method):</p>

<pre><code class="python">from pathlib import Path
import os.path
p1 = os.path.join('src', 'my_package')
p2 = Path('src/my_package')
</code></pre>

<p>The <code>os.fspath</code> function will now normalize both of these types of paths to strings:</p>

<pre><code class="pycon">&gt;&gt;&gt; from os import fspath
&gt;&gt;&gt; fspath(p1), fspath(p2)
('src/my_package', 'src/my_package')
</code></pre>

<p>And the <code>Path</code> class will now accept both of these types of paths and convert them to <code>Path</code> objects:</p>

<pre><code class="pycon">&gt;&gt;&gt; Path(p1), Path(p2)
(PosixPath('src/my_package'), PosixPath('src/my_package'))
</code></pre>

<p>That means you could convert the output of the <code>make_editorconfig</code> function back into a <code>Path</code> object if you wanted to:</p>

<pre><code class="pycon">&gt;&gt;&gt; from pathlib import Path
&gt;&gt;&gt; Path(make_editorconfig(Path('src/my_package')))
PosixPath('src/my_package/.editorconfig')
</code></pre>

<p>Though of course a better long-term approach would be to rewrite the <code>make_editorconfig</code> function to use <code>pathlib</code> instead.</p>

<h2>pathlib is too slow</h2>

<p>I&rsquo;ve heard this concern come up a few times: <code>pathlib</code> is just too slow.</p>

<p>It&rsquo;s true that <code>pathlib</code> can be slow.
Creating thousands of <code>Path</code> objects can make a noticeable impact on your code.</p>

<p>I decided to test the performance difference between <code>pathlib</code> and the alternative on my own machine using two different programs that both look for all <code>.py</code> files below the current directory.</p>

<p>Here&rsquo;s the <code>os.walk</code> version:</p>

<pre><code class="python">from os import getcwd, walk


extension = '.py'
count = 0
for root, directories, filenames in walk(getcwd()):
    for filename in filenames:
        if filename.endswith(extension):
            count += 1
print(f"{count} Python files found")
</code></pre>

<p>Here&rsquo;s the <code>Path.rglob</code> version:</p>

<pre><code class="python">from pathlib import Path


extension = '.py'
count = 0
for filename in Path.cwd().rglob(f'*{extension}'):
    count += 1
print(f"{count} Python files found")
</code></pre>

<p>Testing runtimes for programs that rely on filesystem accesses is tricky because runtimes vary greatly, so I reran each script 10 times and compared the best runtime of each.</p>

<p>Both scripts found 97,507 Python files in the directory I ran them in.
The first one finished in 1.914 seconds (best out of 10 runs).
The second one finished in 3.430 seconds (best out of 10 runs).</p>

<p>When I set <code>extension = ''</code> these find about 600,000 files and the differences spread a little further apart.
The first runs in 1.888 seconds and the second in 7.485 seconds.</p>

<p>So the <code>pathlib</code> version of this program <strong>ran twice as slow</strong> for <code>.py</code> files and <strong>four times as slow</strong> for every file in my home directory.
<strong>The <code>pathlib</code> code was indeed slower</strong>, much slower percentage-wise.</p>

<p>But in my case, this speed difference doesn&rsquo;t matter much.
I searched for every file in my home directory and lost 6 seconds to the slower version of my code.
If I needed to scale this code to search 10 million files, I&rsquo;d probably want to rewrite it.
But that&rsquo;s a problem I can get to if I experience it.</p>

<p>If you have a tight loop that could use some optimizing and <code>pathlib.Path</code> is one of the bottlenecks that&rsquo;s slowing that loop down, abandon <code>pathlib</code> in that part of your code.
But <strong>don&rsquo;t optimize parts of your code that aren&rsquo;t bottlenecks</strong>: it&rsquo;s a waste of time and often results in less readable code for little gain.</p>

<h2>Improving readability with pathlib</h2>

<p>I&rsquo;d like to wrap up these thoughts by ending with some <code>pathlib</code> refactorings.
I&rsquo;ve taken a couple small examples of code that work with files and refactored these examples to use <code>pathlib</code> instead.
I&rsquo;ll mostly leave these code blocks without comment and let you be the judge of which versions you like best.</p>

<p>Here&rsquo;s the <code>make_editorconfig</code> function we saw earlier:</p>

<pre><code class="python">import os
import os.path


def make_editorconfig(dir_path):
    """Create .editorconfig file in given directory and return filename."""
    filename = os.path.join(dir_path, '.editorconfig')
    if not os.path.exists(filename):
        os.makedirs(dir_path, exist_ok=True)
        open(filename, mode='wt').write('')
    return filename
</code></pre>

<p>And here&rsquo;s the same function using <code>pathlib.Path</code> instead:</p>

<pre><code class="python">from pathlib import Path


def make_editorconfig(dir_path):
    """Create .editorconfig file in given directory and return filepath."""
    path = Path(dir_path, '.editorconfig')
    if not path.exists():
        path.parent.mkdir(exist_ok=True, parent=True)
        path.touch()
    return path
</code></pre>

<p>Here&rsquo;s a command-line program that accepts a string representing a directory and prints the contents of the <code>.gitignore</code> file in that directory if one exists:</p>

<pre><code class="python">import os.path
import sys


directory = sys.argv[1]
ignore_filename = os.path.join(directory, '.gitignore')
if os.path.isfile(ignore_filename):
    with open(ignore_filename, mode='rt') as ignore_file:
        print(ignore_file.read(), end='')
</code></pre>

<p>This is the same code using <code>pathlib.Path</code>:</p>

<pre><code class="python">from pathlib import Path
import sys


directory = Path(sys.argv[1])
ignore_path = directory / '.gitignore'
if ignore_path.is_file():
    print(ignore_path.read_text(), end='')
</code></pre>

<p>And here&rsquo;s some code that prints all groups of files in and below the current directory which are duplicates:</p>

<pre><code class="python">from collections import defaultdict
from hashlib import md5
from os import getcwd, walk
import os.path


def find_files(filepath):
    for root, directories, filenames in walk(filepath):
        for filename in filenames:
            yield os.path.join(root, filename)


file_hashes = defaultdict(list)
for path in find_files(getcwd()):
    with open(path, mode='rb') as my_file:
        file_hash = md5(my_file.read()).hexdigest()
        file_hashes[file_hash].append(path)

for paths in file_hashes.values():
    if len(paths) &gt; 1:
        print("Duplicate files found:")
        print(*paths, sep='\n')
</code></pre>

<p>This is the same code that uses <code>pathlib.Path</code> instead:</p>

<pre><code class="python">from collections import defaultdict
from hashlib import md5
from pathlib import Path


def find_files(filepath):
    for path in Path(filepath).rglob('*'):
        if path.is_file():
            yield path


file_hashes = defaultdict(list)
for path in find_files(Path.cwd()):
    file_hash = md5(path.read_bytes()).hexdigest()
    file_hashes[file_hash].append(path)

for paths in file_hashes.values():
    if len(paths) &gt; 1:
        print("Duplicate files found:")
        print(*paths, sep='\n')
</code></pre>

<p>The changes here are subtle, but I think they add up.
I prefer this <code>pathlib</code>-refactored version.</p>

<h2>Start using pathlib.Path objects</h2>

<p>Let&rsquo;s recap.</p>

<p>The <code>/</code> separators in <code>pathlib.Path</code> strings are automatically converted to the correct path separator based on the operating system you&rsquo;re on.
This is a huge feature that can make for code that is <strong>more readable and more certain to be free of path-related bugs</strong>.</p>

<pre><code class="pycon">&gt;&gt;&gt; path1 = Path('dir', 'file')
&gt;&gt;&gt; path2 = Path('dir') / 'file'
&gt;&gt;&gt; path3 = Path('dir/file')
&gt;&gt;&gt; path3
WindowsPath('dir/file')
&gt;&gt;&gt; path1 == path2 == path3
True
</code></pre>

<p>The Python standard library and built-ins (like <code>open</code>) also accept <code>pathlib.Path</code> objects now.
This means <strong>you can start using pathlib, even if your dependencies don&rsquo;t</strong>!</p>

<pre><code class="python">from shutil import move

def rename_and_redirect(old_filename, new_filename):
    move(old, new)
    with open(old, mode='wt') as f:
        f.write(f'This file has moved to {new}')
</code></pre>

<pre><code class="pycon">&gt;&gt;&gt; from pathlib import Path
&gt;&gt;&gt; old, new = Path('old.txt'), Path('new.txt')
&gt;&gt;&gt; rename_and_redirect(old, new)
&gt;&gt;&gt; old.read_text()
'This file has moved to new.txt'
</code></pre>

<p>And if you don&rsquo;t like <code>pathlib</code>, you can use a third-party library that provides the same path-like interface.
This is great because <strong>even if you&rsquo;re not a fan of <code>pathlib</code> you&rsquo;ll still benefit from the new changes detailed in PEP 519</strong>.</p>

<pre><code class="pycon">&gt;&gt;&gt; from plumbum import Path
&gt;&gt;&gt; my_path = Path('old.txt')
&gt;&gt;&gt; with open(my_path) as f:
...     print(f.read())
...
This file has moved to new.txt
</code></pre>

<p>While <code>pathlib</code> is sometimes slower than the alternative(s), the cases where this matters are somewhat rare (in my experience at least) and <strong>you can always jump back to using path strings for parts of your code that are particularly performance sensitive</strong>.</p>

<p>And in general, <code>pathlib</code> makes for more readable code.
Here&rsquo;s a succinct and descriptive Python script to demonstrate my point:</p>

<pre><code class="python">from pathlib import Path
gitignore = Path('.gitignore')
if gitignore.is_file():
    print(gitignore.read_text(), end='')
</code></pre>

<p>The <code>pathlib</code> module is lovely: start using it!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why you should be using pathlib]]></title>
    <link href="http://treyhunner.com/2018/12/why-you-should-be-using-pathlib/"/>
    <updated>2018-12-21T14:00:00-08:00</updated>
    <id>http://treyhunner.com/2018/12/why-you-should-be-using-pathlib</id>
    <content type="html"><![CDATA[<p>When I discovered Python&rsquo;s new <a href="https://docs.python.org/3/library/pathlib.html">pathlib</a> module a few years ago, I initially wrote it off as being a slightly more awkward and unnecessarily object-oriented version of the <code>os.path</code> module.
I was wrong.
Python&rsquo;s <code>pathlib</code> module is actually <a href="https://jefftriplett.com/2017/pathlib-is-wonderful/">wonderful</a>!</p>

<p>In this article I&rsquo;m going to try to sell you on <code>pathlib</code>.
I hope that this article will inspire you to <strong>use Python&rsquo;s <code>pathlib</code> module pretty much anytime you need to work with files in Python</strong>.</p>

<p><strong>Update</strong>: I wrote a follow-up article to address further comments and concerns that were raised after this one.  Read this article first and then take a look at <a href="https://treyhunner.com/2019/01/no-really-pathlib-is-great/">the follow-up article here</a>.</p>

<h2>os.path is clunky</h2>

<p>The <code>os.path</code> module has always been what we reached for to work with paths in Python.
It&rsquo;s got pretty much all you need, but it can be very clunky sometimes.</p>

<p>Should you import it like this?</p>

<pre><code class="python">import os.path

BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
TEMPLATES_DIR = os.path.join(BASE_DIR, 'templates')
</code></pre>

<p>Or like this?</p>

<pre><code class="python">from os.path import abspath, dirname, join

BASE_DIR = dirname(dirname(abspath(__file__)))
TEMPLATES_DIR = join(BASE_DIR, 'templates')
</code></pre>

<p>Or maybe that <code>join</code> function is too generically named&hellip; so we could do this instead:</p>

<pre><code class="python">from os.path import abspath, dirname, join as joinpath

BASE_DIR = dirname(dirname(abspath(__file__)))
TEMPLATES_DIR = joinpath(BASE_DIR, 'templates')
</code></pre>

<p>I find all of these a bit awkward.
We&rsquo;re passing strings into functions that return strings which we then pass into other functions that return strings.
All of these strings happen to represent paths, but they&rsquo;re still just strings.</p>

<p>The string-in-string-out functions in <code>os.path</code> are really awkward when nested because the code has to be read from the inside out.
Wouldn&rsquo;t it be nice if we could take these nested function calls and turn them into chained method calls instead?</p>

<p>With the <code>pathlib</code> module we can!</p>

<pre><code class="python">from pathlib import Path

BASE_DIR = Path(__file__).resolve().parent.parent
TEMPLATES_DIR = BASE_DIR.joinpath('templates')
</code></pre>

<p>The <code>os.path</code> module requires function nesting, but <strong>the <code>pathlib</code> modules&#8217; <code>Path</code> class allows us to chain methods and attributes</strong> on <code>Path</code> objects to get an equivalent path representation.</p>

<p>I know what you&rsquo;re thinking: wait these <code>Path</code> objects aren&rsquo;t the same thing: they&rsquo;re objects, not path strings!
I&rsquo;ll address that later (hint: these can pretty much be used interchangeably with path strings).</p>

<h2>The os module is crowded</h2>

<p>Python&rsquo;s classic <code>os.path</code> module is just for working with paths.
Once you want to actually <em>do</em> something with a path (e.g. create a directory) you&rsquo;ll need to reach for another Python module, often the <code>os</code> module.</p>

<p>The <code>os</code> module has lots of utilities for working with files and directories: <code>mkdir</code>, <code>getcwd</code>, <code>chmod</code>, <code>stat</code>, <code>remove</code>, <code>rename</code>, and <code>rmdir</code>.
Also <code>chdir</code>, <code>link</code>, <code>walk</code>, <code>listdir</code>, <code>makedirs</code>, <code>renames</code>, <code>removedirs</code>, <code>unlink</code> (same as <code>remove</code>), and <code>symlink</code>.
And a bunch of other stuff that isn&rsquo;t related to the filesystems at all: <code>fork</code>, <code>getenv</code>, <code>putenv</code>, <code>environ</code>, <code>getlogin</code>, and <code>system</code>.
Plus dozens of things I didn&rsquo;t mention in this paragraph.</p>

<p><strong>Python&rsquo;s <code>os</code> module does a little bit of everything; it&rsquo;s sort of a junk drawer for system-related stuff</strong>.
There&rsquo;s a lot of lovely stuff in the <code>os</code> module, but it can be hard to find what you&rsquo;re looking for sometimes:
if you&rsquo;re looking for path-related or filesystem-related things in the <code>os</code> module, you&rsquo;ll need to do a bit of digging.</p>

<p>The <code>pathlib</code> module replaces many of these filesystem-related <code>os</code> utilities with methods on the <code>Path</code> object.</p>

<p>Here&rsquo;s some code that makes a <code>src/__pypackages__</code> directory and renames our <code>.editorconfig</code> file to <code>src/.editorconfig</code>:</p>

<pre><code class="python">import os
import os.path

os.makedirs(os.path.join('src', '__pypackages__'), exist_ok=True)
os.rename('.editorconfig', os.path.join('src', '.editorconfig'))
</code></pre>

<p>This code does the same thing using <code>Path</code> objects:</p>

<pre><code class="python">from pathlib import Path

Path('src/__pypackages__').mkdir(parents=True, exist_ok=True)
Path('.editorconfig').rename('src/.editorconfig')
</code></pre>

<p>Notice that the <code>pathlib</code> code puts the path first because of method chaining!</p>

<p>As the Zen of Python says, &ldquo;namespaces are one honking great idea, let&rsquo;s do more of those&rdquo;.
The <code>os</code> module is a very large namespace with a bunch of stuff in it.
<strong>The pathlib.Path class is a much smaller and more specific namespace than the os module</strong>.
Plus the methods in this <code>Path</code> namespace return <code>Path</code> objects, which allows for method chaining instead of nested string-iful function calls.</p>

<h2>Don&rsquo;t forget about the glob module!</h2>

<p>The <code>os</code> and <code>os.path</code> modules aren&rsquo;t the only filepath/filesystem-related utilities in the Python standard library.
The <code>glob</code> module is another handy path-related module.</p>

<p>We can use the <code>glob.glob</code> function for finding files that match a certain pattern:</p>

<pre><code class="python">from glob import glob

top_level_csv_files = glob('*.csv')
all_csv_files = glob('**/*.csv', recursive=True)
</code></pre>

<p>The new <code>pathlib</code> module includes glob-like utilities as well.</p>

<pre><code class="python">from pathlib import Path

top_level_csv_files = Path.cwd().glob('*.csv')
all_csv_files = Path.cwd().rglob('*.csv')
</code></pre>

<p>After you&rsquo;ve started using <code>pathlib</code> more heavily, <strong>you can pretty much forget about the glob module entirely</strong>: you&rsquo;ve got all the glob functionality you need with <code>Path</code> objects.</p>

<h2>pathlib makes the simple cases simpler</h2>

<p>The <code>pathlib</code> module makes a number of complex cases somewhat simpler, but <strong>it also makes some of the simple cases even simpler</strong>.</p>

<p>Need to read all the text in one or more files?</p>

<p>You could open the file, read its contents and close the file using a <code>with</code> block:</p>

<pre><code class="python">from glob import glob

file_contents = []
for filename in glob('**/*.py', recursive=True):
    with open(filename) as python_file:
        file_contents.append(python_file.read())
</code></pre>

<p>Or you could use the <code>read_text</code> method on <code>Path</code> objects and a list comprehension to read the file contents into a new list all in one line:</p>

<pre><code class="python">from pathlib import Path

file_contents = [
    path.read_text()
    for path in Path.cwd().rglob('*.py')
]
</code></pre>

<p>What if you need to write to a file?</p>

<p>You could use the <code>open</code> context manager again:</p>

<pre><code class="python">with open('.editorconfig') as config:
    config.write('# config goes here')
</code></pre>

<p>Or you could use the <code>write_text</code> method:</p>

<pre><code class="python">Path('.editorconfig').write_text('# config goes here')
</code></pre>

<p>If you prefer using <code>open</code>, whether as a context manager or otherwise, you could instead use the <code>open</code> method on your <code>Path</code> object:</p>

<pre><code class="python">from pathlib import Path

path = Path('.editorconfig')
with path.open(mode='wt') as config:
    config.write('# config goes here')
</code></pre>

<p>Or, as of Python 3.6, you can even pass your <code>Path</code> object to the built-in <code>open</code> function:</p>

<pre><code class="python">from pathlib import Path

path = Path('.editorconfig')
with open(path, mode='wt') as config:
    config.write('# config goes here')
</code></pre>

<h2>Path objects make your code more explicit</h2>

<p>What do the following 3 variables point to?
What do their values represent?</p>

<pre><code class="python">person = '{"name": "Trey Hunner", "location": "San Diego"}'
pycon_2019 = "2019-05-01"
home_directory = '/home/trey'
</code></pre>

<p>Each of those variables points to a string.</p>

<p>Those strings represent different things: one is a JSON blob, one is a date, and one is a file path.</p>

<p>These are a little bit more useful representations for these objects:</p>

<pre><code class="python">from datetime import date
from pathlib import Path

person = {"name": "Trey Hunner", "location": "San Diego"}
pycon_2019 = date(2019, 5, 1)
home_directory = Path('/home/trey')
</code></pre>

<p>JSON objects deserialize to dictionaries, dates are represented natively using <code>datetime.date</code> objects, and <strong>filesystem paths can now be generically represented using <code>pathlib.Path</code> objects</strong>.</p>

<p>Using <code>Path</code> objects makes your code more explicit.
If you&rsquo;re trying to represent a date, you can use a <code>date</code> object.
If you&rsquo;re trying to represent a filepath, you can use a <code>Path</code> object.</p>

<p>I&rsquo;m not a strong advocate of object-oriented programming.
Classes add another layer of abstraction and abstractions can sometimes add more complexity than simplicity.
But the <code>pathlib.Path</code> class is <strong>a useful abstraction</strong>.
It&rsquo;s also quickly becoming a universally recognized abstraction.</p>

<p>Thanks to <a href="https://www.python.org/dev/peps/pep-0519/#standard-library-changes">PEP 519</a>, file path objects are now becoming the standard for working with paths.
As of Python 3.6, the built-in <code>open</code> function and the various functions in the <code>os</code>, <code>shutil</code>, and <code>os.path</code> modules all work properly with <code>pathlib.Path</code> objects.
<strong>You can start using pathlib today without changing most of your code that works with paths</strong>!</p>

<h2>What&rsquo;s missing from pathlib?</h2>

<p>While <code>pathlib</code> is great, it&rsquo;s not all-encompassing.
There are definitely <strong>a few missing features I&rsquo;ve stumbled upon that I wish the <code>pathlib</code> module included</strong>.</p>

<p>The first gap I&rsquo;ve noticed is the lack of <code>shutil</code> equivalents within the <code>pathlib.Path</code> methods.</p>

<p>While you can pass <code>Path</code> objects (and path-like objects) to the higher-level <code>shutil</code> functions for copying/deleting/moving files and directories, there&rsquo;s no equivalent to these functions on <code>Path</code> objects.</p>

<p>So to copy a file you still have to do something like this:</p>

<pre><code class="python">from pathlib import Path
from shutil import copyfile

source = Path('old_file.txt')
destination = Path('new_file.txt')
copyfile(source, destination)
</code></pre>

<p>There&rsquo;s also no <code>pathlib</code> equivalent of <code>os.chdir</code>.</p>

<p>This just means you&rsquo;ll need to import <code>chdir</code> if you ever need to change the current working directory:</p>

<pre><code class="python">from pathlib import Path
from os import chdir

parent = Path('..')
chdir(parent)
</code></pre>

<p>The <code>os.walk</code> function has no <code>pathlib</code> equivalent either.
Though you can make your own <code>walk</code>-like functions using <code>pathlib</code> fairly easily.</p>

<p>My hope is that <code>pathlib.Path</code> objects might eventually include methods for some of these missing operations.
But even with these missing features, <strong>I still find it much more manageable to use &ldquo;<code>pathlib</code> and friends&rdquo; than &ldquo;<code>os.path</code> and friends&rdquo;</strong>.</p>

<h2>Should you always use pathlib?</h2>

<p>Since Python 3.6, <strong>pathlib.Path objects work nearly everywhere you&rsquo;re already using path strings</strong>.
So I see no reason <em>not</em> to use <code>pathlib</code> if you&rsquo;re on Python 3.6 (or higher).</p>

<p>If you&rsquo;re on an earlier version of Python 3, you can always wrap your <code>Path</code> object in a <code>str</code> call to get a string out of it when you need an escape hatch back to string land.
It&rsquo;s awkward but it works:</p>

<pre><code class="python">from os import chdir
from pathlib import Path

chdir(Path('/home/trey'))  # Works on Python 3.6+
chdir(str(Path('/home/trey')))  # Works on earlier versions also
</code></pre>

<p>Regardless of which version of Python 3 you&rsquo;re on, I would recommend giving <code>pathlib</code> a try.</p>

<p>And if you&rsquo;re stuck on Python 2 still (the clock is ticking!) the third-party <a href="https://github.com/mcmtroffaes/pathlib2">pathlib2</a> module on PyPI is a backport so you can use <code>pathlib</code> on any version of Python.</p>

<p>I find that using <code>pathlib</code> often makes my code more readable.
Most of my code that works with files now defaults to using <code>pathlib</code> and I recommend that you do the same.
<strong>If you can use <code>pathlib</code>, you should</strong>.</p>

<p>If you&rsquo;d like to continue reading about pathlib, check out my follow-up article called <a href="https://treyhunner.com/2019/01/no-really-pathlib-is-great/">No really, pathlib is great</a>.</p>
]]></content>
  </entry>
  
</feed>
